template<typename T>
struct MST {
    int n,m,inf;
    vector<vector<pair<int, T>>> adj;
    vector<tuple<T,int,int>> E;
    vector<bool> vis;
    vector<T> dis;
    vector<int> fa;
    MST() {};
    MST(int _n,int _m ,T _d = 1e9) : n(_n),m(_m),inf(_d){
        Init(_n);
    }
    void Init(int _n) {
        vis.assign(_n, false);
        dis.assign(_n, inf);
        adj.assign(_n, {});
    }
    void addEdge1(int u, int v, T w) {
        adj[u].emplace_back(v, w);
    }
    void addEdge2(int u, int v, T w) {
        adj[u].emplace_back(v, w);
        adj[v].emplace_back(u, w);
    }
    void addEdge3(int u,int v,T w){
        E.emplace_back(w,u,v);
    }
    int find(int x) {
        while (x != fa[x]) {
            x = fa[x] = fa[fa[x]];
        }
        return x;
    }
    T Prim(int s = 1) {
        dis[s] = 0;
        T ans = 0;int cnt = 0;
        for (int i = 1; i < n; i++) {
            int u = 0;
            for (int j = 1; j < n; j++)
                if (!vis[j] && dis[j] < dis[u]) u = j;

            ans += dis[u];vis[u] = true;
            if (dis[u] != inf) cnt++;

            for (auto [v, w]: adj[u])
                if (dis[v] > w) dis[v] = w;
        }
        if (cnt != n - 1) return -1;
        return ans;
    }

    T Kruskal(int s = 1){
        if(fa.empty()) fa.assign(n,0);
        iota(fa.begin(),fa.end(),0);
        sort(E.begin(),E.end());
        T ans=0;int cnt=0;
        for(int i=0;i<m;i++){
            auto [w,u,v]=E[i];
            int fu=find(u),fv=find(v);
            if(fu!=fv){
                fa[fu]=fv;
                ans+=w;
                cnt++;
            }
        }
        if(cnt!=n-2) return -1;
        return ans;
    }
};