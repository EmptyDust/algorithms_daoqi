//加强版线段树



#include <iostream>
using namespace std;
#define ll long long
#define N 400005
#define mod 571373
struct tree{
	ll l,r;
	ll sum;
	ll add;
	ll mul;
}tr[N];
ll a[N];

void build(ll x,ll l,ll r){
	//初始化标记
	if(l==r){
		tr[x]={l,r,a[l],0,1};
		return;
	}
	tr[x]={l,r,0,0,1};
	ll mid=(l+r)/2;
	build(x*2,l,mid);
	build(x*2+1,mid+1,r);
	tr[x].sum=tr[x*2].sum+tr[x*2+1].sum;
	tr[x].sum%=mod;
	return;
}
//更新数据，核心代码
void update(ll x){
	//更新和
	tr[x*2].sum=(tr[x*2].sum*tr[x].mul+(tr[x*2].r-tr[x*2].l+1)*tr[x].add)%mod;
	tr[x*2+1].sum=(tr[x*2+1].sum*tr[x].mul+(tr[x*2+1].r-tr[x*2+1].l+1)*tr[x].add)%mod;

	//更新标记
	tr[x*2].mul=(tr[x*2].mul*tr[x].mul)%mod;
	tr[x*2+1].mul=(tr[x*2+1].mul*tr[x].mul)%mod;
	tr[x*2].add=(tr[x*2].add*tr[x].mul+tr[x].add)%mod;
	tr[x*2+1].add=(tr[x*2+1].add*tr[x].mul+tr[x].add)%mod;

	//恢复
	tr[x].add=0;
	tr[x].mul=1;
}


//更新数据,乘法
void modify1(ll x,ll l,ll r,ll k){
	if(l<=tr[x].l&&r>=tr[x].r){
		tr[x].sum=(tr[x].sum*k)%mod;
		tr[x].mul=(tr[x].mul*k)%mod;
		tr[x].add=(tr[x].add*k)%mod;
		return;
	}

	update(x);
	ll mid=(tr[x].l+tr[x].r)/2;
	if(l<=mid) modify1(x*2,l,r,k);
	if(r>mid) modify1(x*2+1,l,r,k);
	tr[x].sum=(tr[x*2].sum+tr[x*2+1].sum)%mod;
	return;
}

//更新数据,加法
void modify2(ll x,ll l,ll r,ll k){
	if(l<=tr[x].l&&r>=tr[x].r){
		tr[x].sum=(tr[x].sum+(tr[x].r-tr[x].l+1)*k)%mod;
		tr[x].add=(tr[x].add+k)%mod;
		return;
	}

	update(x);
	ll mid=(tr[x].l+tr[x].r)/2;
	if(l<=mid) modify2(x*2,l,r,k);
	if(r>mid) modify2(x*2+1,l,r,k);
	tr[x].sum=(tr[x*2].sum+tr[x*2+1].sum)%mod;
	return;
}
//查询
ll query(ll x,ll l,ll r){
	if(l<=tr[x].l&&r>=tr[x].r) return tr[x].sum;

	update(x);
	ll mid=(tr[x].l+tr[x].r)/2;
	ll sum=0;
	if(l<=mid) sum+=query(x*2,l,r);
	if(r>mid) sum+=query(x*2+1,l,r);
	sum%=mod;
	return sum;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);cout.tie(nullptr);
	ll n,m,p;cin>>n>>m>>p;
	for(int i=1;i<=n;i++) cin>>a[i];
	build(1,1,n);
	for(int i=0;i<m;i++){
		int choice;cin>>choice;
		if(choice==1){
			ll x,y,k;cin>>x>>y>>k;
			modify1(1,x,y,k);
		}else if(choice==2){
			ll x,y,k;cin>>x>>y>>k;
			modify2(1,x,y,k);
		}else{
			ll x,y;cin>>x>>y;
			cout<<query(1,x,y)<<endl;
		}
	}
	return 0;
}




#include <bits/stdc++.h>
using namespace std;
#define ll long long
//树上查询与修改
// 树链剖分加线段树
//重儿子：父节点的所有儿子中子树节点数目最多的节点
//轻儿子：重儿子以外的节点
//重边：父节点和重儿子连成的边
//轻边：父节点和轻儿子连成的边
//重链：多条重边连接而成的路径
const int N=5e5+5;
vector<int> e[N],fa(N),dep(N),son(N),sz(N),top(N);
//fa[u]:存u的父节点，dep[u]：u的深度，son[u]:存u的重儿子，sz[u],存以u为根的子树的节点数，top[u]:存u所在重链的顶点
int w[N],id[N],nw[N],cnt;
//id[u]:存u剖分后的新编号，nw[cnt]:存新编号在树中所对应节点的权值
struct tree{
    int l,r;
    ll sum;
    int add;
}tr[N*4];
void dfs1(int u,int father){//搞fa,dep,son
    fa[u]=father,dep[u]=dep[father]+1,sz[u]=1;
    for(int v:e[u]){
        if(v==father) continue;
        dfs1(v,u);
        sz[u]+=sz[v];
        if(sz[son[u]]<sz[v]) son[u]=v;
    }
}

void dfs2(int u,int t){//搞top
    top[u]=t;//记录链头
    id[u]=++cnt,nw[cnt]=w[u];
    if(!son[u]) return;//无重儿子，返回
    dfs2(son[u],t);//搜重儿子
    for(int v:e[u]){
        if(v==fa[u]||v==son[u]) continue;
        dfs2(v,v);//搜轻儿子,轻儿子一定是某条重链的头节点
    }
}
void pushup(int u){
    tr[u].sum=tr[u*2].sum+tr[u*2+1].sum;
}
void pushdown(ll x) {
    if (tr[x].add) {
        tr[x * 2].sum += (tr[x * 2].r - tr[x * 2 ].l + 1) * tr[x].add;
        tr[x * 2+1].sum += (tr[x * 2+1].r - tr[x * 2+1].l + 1) * tr[x].add;
        tr[x * 2].add += tr[x].add;
        tr[x * 2 + 1].add += tr[x].add;
        tr[x].add = 0;
    }
}
void build(int u,int l,int r){
    if(l==r) {
        tr[u] = {l, r, nw[r], 0};
        return;
    }else{
        tr[u].l=l,tr[u].r=r;
    }
    int mid=(l+r)>>1;
    pushdown(u);
    build(u*2,l,mid);
    build(u*2+1,mid+1,r);
    pushup(u);
}

ll query(int u,int l,int r){
    if(l<=tr[u].l&&r>=tr[u].r){
        return tr[u].sum;
    }
    pushdown(u);
    ll ans=0;
    int mid=(tr[u].l+tr[u].r)>>1;
    if(l<=mid) ans+=query(u*2,l,r);
    if(r>mid) ans+=query(u*2+1,l,r);
    return ans;
}

ll query_path(int u,int v){//查询一棵树上u节点和v节点最短路径上的节点值的和
    ll res=0;
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        res+=query(1,id[top[u]],id[u]);
        u=fa[top[u]];
    }
    if(dep[u]<dep[v]) swap(u,v);
    res+=query(1,id[v],id[u]);
    return res;
}

void update(int u,int l,int r,int v){
    if(l<=tr[u].l&&r>=tr[u].r){
        tr[u].add+=v;
        tr[u].sum+=(tr[u].r-tr[u].l+1)*v;
        return;
    }
    pushdown(u);
    int mid=(tr[u].l+tr[u].r)>>1;
    if(l<=mid) update(u*2,l,r,v);
    if(r>mid) update(u*2+1,l,r,v);
    pushup(u);
}

void update_path(int u,int v,int val){
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        update(1,id[top[u]],id[u],val);
        u=fa[top[u]];
    }
    if(dep[u]<dep[v]) swap(u,v);
    update(1,id[v],id[u],val);
}










#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N=3e5+5;
//可持久化线段树(主席树)
#define N 200005
#define lc(x) tr[x].ch[0]
#define rc(x) tr[x].ch[1]
int n,m,a[N];
vector<int> v;
struct node{
    int ch[2];
    int s;//节点值域中有多少数
}tr[N*22];
int root[N],idx;
void build(int &x,int l,int r){
    x=++idx;
    if(l==r) return;
    int mid=(l+r)>>1;
    build(lc(x),l,mid);
    build(rc(x),mid+1,r);
}
void insert(int x,int &y,int l,int r,int v){
    y=++idx;tr[y]=tr[x];tr[y].s++;
    if(l==r) return;
    int mid=(l+r)>>1;
    if(v<=mid) insert(lc(x),lc(y),l,mid,v);
    else insert(rc(x),rc(y),mid+1,r,v);
}

int query(int x,int y,int l,int r,int k){
    if(l==r) return l;
    int mid=(l+r)>>1;
    int s=tr[lc(y)].s-tr[lc(x)].s;
    if(k<=s) return query(lc(x),lc(y),l,mid,k);
    else return query(rc(x),rc(y),mid+1,r,k-s);
}
int getid(int x){
    return lower_bound(v.begin(),v.end(),x)-v.begin()+1;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];v.push_back(a[i]);
    }
    sort(v.begin(),v.end());
    v.erase(unique(v.begin(),v.end()),v.end());//进行离散化
    int vn=v.size();
    build(root[0],1,vn);
    for(int i=1;i<=n;i++){
        int id=getid(a[i]);
        insert(root[i-1],root[i],1,vn,id);
    }
    for(int i=1;i<=m;i++){
        int l,r,k;cin>>l>>r>>k;
        int id=query(root[l-1],root[r],1,vn,k)-1;
        cout<<v[id]<<endl;
    }
    system("pause");
    return 0;
}





#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+5,len=23;
//可持久化数组
#define lc(x) tr[x].l
#define rc(x) tr[x].r
int n,m,a[N];
struct node{
    int l,r;
    int v;
}tr[N*25];
int root[N],idx;
void build(int &x,int l,int r){
    x=++idx;
    if(l==r){
        tr[x].v=a[l];
        return;
    }
    int mid=(l+r)>>1;
    build(lc(x),l,mid);
    build(rc(x),mid+1,r);
}
void modify(int &x,int y,int l,int r,int pos,int v){
    x=++idx;
    tr[x].l=tr[y].l;tr[x].r=tr[y].r;tr[x].v=tr[y].v;
    if(l==r){
        tr[x].v=v;
        return;
    }
    int mid=(l+r)>>1;
    if(pos<=mid) modify(lc(x),lc(y),l,mid,pos,v);
    else modify(rc(x),rc(y),mid+1,r,pos,v);
}
int query(int x,int l,int r,int pos){
    if(l==r) return tr[x].v;
    int mid=(l+r)>>1;
    if(pos<=mid) return query(lc(x),l,mid,pos);
    else return query(rc(x),mid+1,r,pos);
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    build(root[0],1,n);

    for(int i=1;i<=m;i++){
        int v,op;cin>>v>>op;
        if(op==1){
            int p,val;cin>>p>>val;
            modify(root[i],root[v],1,n,p,val);
        }else{
            int p;cin>>p;
            cout<<query(root[v],1,n,p)<<endl;
            root[i]=root[v];
        }
    }
    system("pause");
    return 0;
}
